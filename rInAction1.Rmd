---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

# 一、入门

## 数据构建:

```{r}
age <- c(32,45,25,39,99)
country <- c("US", "US", "UK", "UK", "UK")
date <- c("10/24/08", "10/28/08", "10/01/08", "10/12/08", "05/01/09")
gender <- c("M", "F", "F", "M", "F")
manager <- c(1,2,3,4,5)
q1 <- c(5,3,3,3,2)
q2 <- c(4,5,5,3,2)
q3 <- c(5,2,5,4,1)
q4 <- c(5,5,5,NA,2)
q5 <- c(5,5,2,NA,1)
leaderShip <- data.frame(manager, date, country, gender, age, q1, q2, q3, q4, q5)
```

## 数据框列名重命名:
显示现有列名

```{r}
newName0 <- leaderShip
names(newName0)
```
方法1
```{r}
library(reshape)
newName1 <- rename(newName0, c(manager="managerId", date="testDate"))
names(newName1)
```
方法2
```{r}
newName2 <- newName0
names(newName2)[c(1,2)] <- c("managerId", "testDate")
names(newName2)
```

## 检测是否为空值:

```{r}
is.na(leaderShip$q4)
```
将年龄大于90岁的置为空值:
```{r}
# library(sqldf)
nullData <- leaderShip
# attach(nulldata)
nullData$age[nullData$age>90] <- NA
# detach(nulldata)
nullData
```

## 合并新列:

```{r}
colData1 <- data.frame(manager=c(1,2,3,4,5), newAge=c(leaderShip$age * leaderShip$q1)) #需要有共同列名进行内连接
mergeData <- merge(leaderShip, colData1)
mergeData
```
或使用cbind直接合并
```{r}
colData2 <- data.frame(childern=c(1,0,2,1,3))
cbindData <- cbind(leaderShip, colData2)
cbindData
```

## 添加新行
直接使用rbind, 但要保证列的顺序同量一致

```{r}
rowData <- c(6, "10/15/08", "US", "M", 23, 4, 3, 5, 2, 1, 0)
rbindData <- rbind(leaderShip, rowData)
rbindData
```
## 将日期列的字符型转化为日期型

```{r}
class(leaderShip$date)
```
使用as.Date()


|符号|含义|
|:----:|:----:|
|%d|数字日期|
|%a|星期缩写|
|%A|星期全拼|
|%m|数字月份|
|%b|月份缩写|
|%B|月份全拼|
|%y|两位数字年份|
|%Y|四位数字年份|

```{r}
leaderShip$date <- as.Date(leaderShip$date, "%m/%d/%y")
class(leaderShip$date)
leaderShip
```

## 类型判断与互换:



| 判断 | 转换 |
| :----: | :----: |
|is.numeric()|as.numeric()|
|is.character|as.character()|
|is.vector()|as.vector()|
|is.matrix()|as.matrix()|
|is.data.fram|as.data.frame|
|is.factor()|as.factor()|
|is.logical()|as.logical()|

## 数据排序
order函数列出对象内部的排序名次, 倒序直接添加负号

```{r}
order(leaderShip$age)
order(-leaderShip$age)
```

```{r}
orderData <- leaderShip[order(leaderShip$age),]
orderData
```

## 取子集
选入字段
每行的1-5列

```{r}
leaderShip[,c(1:5)]
```

选入观测
前3行

```{r}
leaderShip[c(1:3),]
```

选择age>40的人员的所有字段
```{r}
leaderShip[which(leaderShip$age>40),]
```

paste0函数
```{r}
paste0("q",1:5,seq="")
```
## 剔除字段
提出q4,q5字段
将q4,q5所在列置为FALSE

```{r}
!names(leaderShip) %in% c("q4","q5")
```
```{r}
leaderShip[(!names(leaderShip) %in% c("q4","q5"))]
```

或直接使用-
减去第9,10列

```{r}
leaderShip[c(-9,-10)]
```

## 使用subset函数
选出年龄小于30或者性别为F的人员的1-5列字段

```{r}
subset(leaderShip, age<30 | gender == "F", select=c(1:5))
```

## 随机抽样sample函数
从1-100中不放回的抽取10个元素,返回抽中的数字

```{r}
sample(1:100, 10, replace = F)
```
以抽中的数字为索引取数
```{r}
leaderShip[sample(1:nrow(leaderShip), 3, replace = F),]
```

使用SQL语句操作数据框
```{r}
library(sqldf)
sqldf("SELECT avg(mpg) AS avg_mpg, avg(disp) AS avg_disp, gear FROM mtcars WHERE cyl IN (4, 6) GROUP BY gear")
```

## 构建成绩表

```{r}
name <- c("J D", "A W", "B M", "D J", "J M", "C C", "R Y", "G K", "J E", "M R")
mathScore <- c(502, 600, 412, 358, 495, 512, 410, 625, 573, 522)
sciScore <- c(95, 99, 80, 82, 75, 85, 80, 95, 89, 86)
engScore <- c(25, 22, 18, 15, 20, 28, 15, 30, 27, 18)
scoreTable <- data.frame(name, mathScore, sciScore, engScore)
scoreTable
```

```{r}
scoreTable$mathScore^0.5
```

|函数|描述|
|:---:|:---:|
|mad()|绝对中位差|
|quantile(x,probs)|返回向量x的分位数probs可以是向量|
|range()|返回值域|
|diff(x, len=n)|滞后差分,len指定滞后项数,默认1|
|scale(x, center=TRUE, scale=TRUE)|对对象x按列进行中心化center=TRUE或标准化scale=TRUE|
|round(x,digits=n)|保留n位小数四舍五入|
|signif(x,digits=n))|保留n位有效数字四舍五入|
|trunc(x)|向0方向截取x的整数部分|
|length(x)|返回x的元素个数|
|中心化|数据-均值|
|标准化|(数据-均值)/标准差|

## 概率函数

[dpqr]distribution_name(x, mean=指定均值, sd=指定标准差)

如下

|函数|含义|
|:---:|:---:|
|pnorm(1.96)|返回1.96分位数的累积概率|
|qnorm(.9)|返回累计概率为90%的分位数|
|dnorm()|密度函数|
|rmorm(n)|生成n个服从该分布的随机数|


|分布名称|缩写|
|:---:|:---:|
|Beta分布|beta|
|二项分布|binom|
|柯西分布|cauchy|
|(非中心)卡方分布|chisp|
|指数分布|exp|
|F分布|f|
|Gamma分布|gamma|
|几何分布|geom|
|超几何分布|hyper|
|对数正态分布|lnorm|
|Logistic分布|logis|
|多项分布|multinom|
|负二项分布|nbinom|
|正态分布|norm|
|泊松分布|pois|
|Wilcoxon符号秩分布|signrank|
|t分布|t|
|均匀分布|unif|
|Weibull分布|weibull|
|Wilcoxon秩和分布|wilcox|


绘制正态曲线
```{r}
normx <- pretty(-3:3,50)
normy <- dnorm(normx)
plot(normx, normy, type="l", xlab = "NormalDevinate", ylab = "Density", yaxs = "i")
```
设置随机数生成种子
```{r}
set.seed(666)
```


## 字符处理函数

|函数|含义|
|:---:|:---:|
|nchar()|返回字符串的字符数量|
|substr(x, start,stop)|返回或替换字符向量的字串substr(x,2,4)返回x的第2-4个字符,也可直接对其赋值|
|grep("pattern", x, fixed=F/T)|在x中搜索pattern,fixed默认为F,则pattern为正则表达式|
|sub("pattern", "replacement", x, fixed=F/T)|在x中搜索pattern,并以replacement替换.fixed同上|
|strsplit(x, "split", fixed=F/T)|以"split"为标志分割x,返回一个列表,fixed同上|
|paste(..., sep="")|以sep为分隔符连接对象|
|toupper()|大写转换|
|tolower()|小写转换|


## 其他函数

|函数|含义|
|:---:|:---:|
|length()|返回对象x的长度|
|seq(from, to, seq)|生成以seq为步长的序列|
|rep(x, n)|将x重复n次|
|cut(x, n)|将连续性向量x分割为有n个水平的因子|
|pretty(x, n)|创建美观的分割点,将x分割为n个等距区间|
|cat(..., file = "myfiles", append = F)|连接对象,以空格分隔|


## 转义字符

```{r}
# ?Quotes
```


|函数|含义|
|:---:|:---:|
|\\n|换行符|
|\\r|回车|
|\\t|制表符|
|\\b|退格键|
|\\a|警报(响铃)|
|\\f|换页|
|\\v|垂直标签|
|\\|反斜杠\\|
|\\'|ASCII单引号'|
|\\"|ASCII引号”|
|\\\`|ASCII重音（反引号）`|
|\\nnn|字符，带有给定的八进制代码（1、2或3位数字）|
|\\xnn|具有给定十六进制代码的字符（1或2个十六进制数字）|
|\\unnnn|具有给定代码的Unicode字符（1--4个十六进制数字）|
|\\Unnnnnnnn|具有给定代码的Unicode字符（1--8十六进制数字）|


```{r}
cat("hello", "\bworld" )
#cat会有空格分隔,使用\b退格一个空格
```

## apply函数

apply(数据对象, margin=维度, 函数, 函数参数...)
sapply()是一个更好用的apply函数

R函数可直接作用于标量,向量,矩阵,数组,数据框
```{r}
rMatrix <- matrix(rnorm(30), nrow=6)
mean(rMatrix) # 得到矩阵全部元素的均值
apply(rMatrix, 1, mean) # 得到第一个维度的均值
apply(rMatrix, 2, mean) # 得到第二个维度的均值
apply(rMatrix, 2, mean, trim=.2) # 得到第二个维度截尾20%的均值
```

## 学生对分数表操作

将学生各科成绩组合为单一指标,并根据该指标,以前20%为"A",下20%为"B",依次排序A-F,最后根据学成姓和名的首字母进行排序

```{r}
# scoreTable
zScore <- scale(scoreTable[,c(2:4)]) # 将成绩表的2-4列成绩中心化,标准化得到z分数作为综合指标
allScore <- apply(zScore, 1, mean) # 求得z分数的均值
newScoreTable <- cbind(scoreTable, allScore) # 组建新成绩表
divScore <- quantile(allScore, c(.8, .6, .4, .2)) # 划出分位数
newScoreTable$grade[newScoreTable$allScore >= divScore[1]] <- "A"
newScoreTable$grade[newScoreTable$allScore < divScore[1] & newScoreTable$allScore >= divScore[2]] <- "B"
newScoreTable$grade[newScoreTable$allScore < divScore[2] & newScoreTable$allScore >= divScore[3]] <- "C"
newScoreTable$grade[newScoreTable$allScore < divScore[3] & newScoreTable$allScore >= divScore[4]] <- "D"
newScoreTable$grade[newScoreTable$allScore < divScore[4]] <- "F" # 按分位数确定grade
stuName <- strsplit(newScoreTable$name, " ") # 以空格为分隔拆分name,返回一个列表
firstName <- sapply(stuName, "[", 1) # "["是一个提取对象某一部分的函数,此处用于提取stuName列表每个元素的第一个或第二个元素
lastName <- sapply(stuName, "[", 2)
newScoreTable <- cbind(firstName, lastName, newScoreTable[-1]) # 去除newScoreTable的第一个旧的name字段,并与拆开的firstName, lastName合并
# order(newScoreTable$firstName, newScoreTable$lastName)
newScoreTable <- newScoreTable[order(newScoreTable$firstName, newScoreTable$lastName),] # 排序
newScoreTable
```

## 控制流

for语句
```{r}
for(i in 1:3){
  print("hello"); # 注意分号
  print("world")
}
```

while语句
```{r}
i <- 5
while(i>0){
  print(i);
  i <- i-1
}
```

if else结构
```{r}
for(i in 1:6){
  if(i%%2==0){
    print(i);
    print("偶数")
  }
  else{
    print(i);
    print("奇数")
  }
}
```

ifelse结构
是为if else的一种紧凑模式
ifelse(条件,TRUE,FALSE)

```{r}
for(i in 1:6){
  ifelse((i%%2==0),{print(i);print("偶数")}, {print(i);print("奇数")})
}
```

switch结构

switch(x,...)
根据x的取值选择对应的语句进行执行

```{r}
feelings <- c("happy", "sad", "afraid")
for(i in feelings){
  print(
  switch(i,
         happy="I am happy",
         sad="Want to cry",
         anger="Calm down",
         cat("NO!"))
        )
}
```


## 用户自定义函数

functionName <- function(参数1,参数2,...){
  语句...
  return(对象)
}

如求一个向量的方差:
```{r}
varOfData <- function(x){
  m <- mean(x)
  x <- (x-m)^2 # 直接对向量进行操作是指向量每个元素进行操作
  sum(x)/(length(x)-1)
}

vectorA <- c(1:10)
varOfData(vectorA)
var(vectorA)
```

```{r}
list(name1=q1, name2=q2)
```


## 数据的整合与重塑

转置
```{r}
myCars <- mtcars[1:5,1:4]
myCars
t(myCars)
```

整合数据
aggregate(x, by = list(变量1, 变量2), 标量函数)

将x数据对象,按list列表中的变量进行分组折叠
具体来说就是
```{r}
attach(mtcars)
aggreData <- aggregate(mtcars, by = list(Group_cyl=cyl, Group_gear=gear),FUN = mean, na.rm=T)
aggreData
detach(mtcars)
# 按照cyl和gear分组,如第一行,cyl=4,gear=3的车子的平均mpg为21.5
```

## reshape包

### 数据融合 melt

先将数据融合为一个关于观测变量的组合,每一行观测都具有唯一标识符,被该观测的索引唯一确定

|ID|TIME|X1|X2|
|:---:|:---:|:---:|:---:|
|1|1|5|6|
|1|2|3|5|
|2|1|6|1|
|2|2|2|4|

每个观测值都可以由ID,TIME,X1或X2唯一确定

|ID|TIME|变量|值|
|:---:|:---:|:---:|:---:|
|1|1|X1|5|
|1|2|X1|3|
|2|1|X1|6|
|2|2|X1|2|
|1|1|X2|6|
|1|2|X2|5|
|2|1|X2|1|
|2|2|X2|4|

```{r}
reID <- c(1,1,2,2)
reTIME <- c(1,2,1,2)
reX1 <- c(5,3,6,2)
reX2 <- c(6,5,1,4)
reData <- data.frame(ID=reID, TIME=reTIME, X1=reX1, X2=reX2)
reData
library(reshape2)
meltData <- melt(reData, id=list("ID", "TIME")) # 不需指定变量的名称
meltData
```

### 数据重铸 cast

castData <- cast(meltData, formula, FUN)
将meltData数据依照给定的formula进行重铸,FUN为可选的数据整合函数

formula形式如
行变量1+行变量2+行变量3+......  ~  列变量1+列变量2+列变量3+....

各个行变量确定了所需的行变量,以确定各行内容
各个列变量确定了所需的列变量,以确定各列内容

```{r}
library(reshape)
castDataA <- cast(meltData, ID+TIME~variable) # 行为ID,TIME,列为variable
castDataA
castDataB <- cast(meltData, ID+variable~TIME) # 行为ID和variable,列为TIME
castDataB
castDataC <- cast(meltData, ID~variable+TIME) # 行为ID,列为variable和TIME
castDataC
castDataD <- cast(meltData, ID~variable, mean) # 行为ID,列为variable,并求相应ID的variable均值
castDataD
```
