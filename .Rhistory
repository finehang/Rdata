a <- seq(0,50,by=.1)
for(i in a){
x[i] <- dchisq(i,4)
}
length(a)
length(x)
plot(0:length(a), x, type = "l")
a <- seq(0.1,50,by=.1)
for(i in a){
x[i] <- dchisq(i,4)
}
length(a)
length(x)
plot(0:length(a), x, type = "l")
library(vcd)
arthData <- table(Arthritis$Improved) # table函数用于提取个单元的计数
arthData
barplot(arthData, main = "BarPlot", xlab = "Improvement", ylab = "Frequency", horiz = T) # horiz为T是横向作图,默认为F
plot(Arthritis$Improved, main = "BarPlot", xlab = "Improvement", ylab = "Frequency", horiz = T)
barData <- table(Arthritis$Improved, Arthritis$Treatment) # 将Improved和Treatment合并为一个table
barplot(barData, main = "Barplot", xlab="Treatment", ylab = "Frequency", col = c("red", "yellow","blue"), legend.text = rownames(barData),beside = F, )
barplot(barData, main = "Barplot", xlab="Treatment", ylab = "Frequency", col = c("red", "yellow","blue"), legend.text = rownames(barData),beside = T)
states <- data.frame(state.region, state.x77)
means <- aggregate(states$Illiteracy, by=list(state.region), FUN = mean) # 数据折叠
means <- means[order(means$x),]
barplot(means$x, names.arg = means$Group.1, cex.names = 0.5, col = c("red", "blue", "yellow", "green"), legend = means$Group.1) # names.arg使用文字向量为直方标签命名, cex.names = 0.5调整字号
title("Mean Of Illiteracy Rate")
library(vcd)
attach(Arthritis)
counts <- table(Treatment, Improved)
spine(counts)
detach(Arthritis)
opar <- par(no.readonly = T)
par(mfrow=c(2,2))
slices <- c(10, 12, 4, 16, 8)
lbls <- c("US", "UK", "AU", "GE", "FR")
pct <- (slices/sum(slices)) * 100
lbls2 <- paste(lbls, " ", pct, "%", sep = "")
pie(slices, labels = lbls, main = "Pie Chart")
pie(slices, labels = lbls2, main = "Pie2", col = rainbow(length(slices)))
library(plotrix)
pie3D(slices, labels = lbls, main = "Pie3D", explode=.8,col = rainbow(length(slices)))
mytable <- table(state.region)
lbls3 <- paste(names(mytable),"\n", mytable)
pie(mytable, labels = lbls3, main = "Pie4")
par(opar)
library(plotrix)
slices <- c(10, 12, 4, 16, 8)
lbls <- c("US", "UK", "AU", "GE", "FR")
fan.plot(slices, labels = lbls, main = "Fan Plot")
# rug(jitter(mtcars$mpg, amount = .01)) # 加上±amount之间的随机分布的数
hist(mtcars$mpg, breaks = 12, col = "red", xlab = "MPG", main = "Hist")
hist(mtcars$mpg, freq=FALSE, breaks = 12, col = "blue", xlab = "MPG", main = "Hist")
rug(jitter(mtcars$mpg))
lines(density(mtcars$mpg), col = "red", lwd = 3) # 加入密度曲线
x <- mtcars$mpg
h <- hist(x, breaks = 12, col = "red", xlab = "MPG", main = "Hist")
xfit <- seq(min(x), max(x), length=40) # 从x最小到x最大均分40段
yfit <- dnorm(xfit, mean = mean(x), sd = sd(x)) # xfit对应的正态分布的概率密度
yfit <- yfit*(diff(h$mids[1:2])*length(x)) # 概率密度乘以(直方的样本量)
lines(xfit, yfit)
den <- density(mtcars$mpg)
plot(den, main = "Density Plot")
den <- density(mtcars$mpg)
plot(den, main = "Density Plot")
polygon(den, col = "red", border = "blue") #按照顶点的XY坐标绘制多边形
rug(mtcars$mpg, col = "brown") # 添加轴须图
library(sm)
attach(mtcars)
cyl.f <- factor(cyl, levels = c(4,6,8), labels = c("4 cylinder", "6 cylinder", "8 cylinder"))
sm.density.compare(mpg, cyl, xlab="MPG")
title("Compare")
colfill <- c(2:(1+length(levels(cyl.f))))
# legend(locator(1), levels(cyl.f), fill = colfill)
detach(mtcars)
boxplot(mtcars$mpg)
boxplot.stats(mtcars$mpg)
boxplot(mpg~cyl, data = mtcars, main="BoxPlot", xlab = "Num Of Cyl", ylab = "MPG",varwidth=T)
boxplot(mpg~cyl, data = mtcars, notch=T, main="BoxPlot", xlab = "Num Of Cyl", ylab = "MPG",varwidth=T)
mtData <- mtcars
mtData$cyl.f <- factor(mtData$cyl, levels = c(4,6,8), labels = c("4", "6", "8"))
mtData$am.f <- factor(mtData$am, levels = c(0,1), labels = c("auto", "standard"))
boxplot(mpg~am.f*cyl.f, data = mtData, varwidth = T, main = "BoxPlot", xlab = "Auto Type")
library(vioplot)
x1 <- mtcars$mpg[mtcars$cyl == 4]
x2 <- mtcars$mpg[mtcars$cyl == 6]
x3 <- mtcars$mpg[mtcars$cyl == 8]
vioplot(x1, x2, x3, names = c("4 cyl", "6 cyl", "8 cyl"), col = "gold")
dotchart(mtcars$mpg, labels = rownames(mtcars), cex = .6, main = "DotChart", xlab = "MPG")
x <- mtcars[order(mtcars$mpg),]
x$cyl <- factor(x$cyl)
x$color[x$cyl == 4] <- "red"
x$color[x$cyl == 6] <- "darkgreen"
x$color[x$cyl == 8] <- "blue"
dotchart(x$mpg, labels = rownames(x), groups = x$cyl, gcolor = "black", pch = 19, color = x$color, main = "Dot", xlab = "MPG", cex = .7)
dataName <- c("mpg", "hp", "wt")
summary(mtcars[dataName])
#计算偏度峰度
myfun <- function(x,na.omit=F){
if(na.omit)
x <- x[!is.na(x)]
m <- mean(x)
n <- length(x)
skew <- (sum((x-m)^3)/n)/((sum((x-m)^2)/n)^(3/2))
kurt <- (sum((x-m)^4)/n)/((sum((x-m)^2)/n)^2)-3
return(c(n=n,mean=m,skew=skew,kurtosis=kurt))
}
sapply(mtcars[dataName], myfun)
library(Hmisc)
describe(mtcars[dataName])
library(pastecs)
stat.desc(mtcars[dataName], norm = T)
library(psych)
describe(mtcars[dataName])
Hmisc::describe(mtcars[dataName]) # 用::来指明用的是那个包里的describe
aggregate(mtcars[dataName], by = list(am=mtcars$am), mean)
doFun <- function(x)(c(mean=mean(x), sd=sd(x)))
# by(mtcars[dataName], mtcars$am, doFun)
# library(doBy)
# summaryBy(mpg+hp+wt~am, data=mtcars, mean)
library(vcd)
mytable <- with(Arthritis, table(Improved))
mytable
prop.table((mytable))*100
library(vcd)
mytable <- with(Arthritis, table(Improved, Treatment))
mytable
mytable2 <- xtabs(~Improved+Treatment, data = Arthritis)
mytable2
margin.table(mytable, 1) # 按行
margin.table(mytable, 2) # 按列
prop.table(mytable, 1) # 按行
prop.table(mytable, 2) # 按列
prop.table(mytable)
addmargins(mytable) # 也可指定仅添加行或列
addmargins(prop.table(mytable))
library(gmodels)
library(vcd)
with(Arthritis, CrossTable(Treatment, Improved))
library(vcd)
mytable3 <- xtabs(~Treatment+Sex+Improved,data = Arthritis)
mytable3
ftable(mytable3)
margin.table(mytable3,1)
margin.table(mytable3,2)
margin.table(mytable3,3)
margin.table(mytable3,c(1,3))
ftable(addmargins(prop.table(mytable3, c(1,2))))
library(vcd)
mytableChi <- xtabs(~Treatment+Improved, data=Arthritis)
mytableChi2 <- xtabs(~Improved+Sex, data=Arthritis)
chisq.test(mytableChi)
chisq.test(mytableChi2)
library(vcd)
mytableFish <- xtabs(~Treatment+Improved, data=Arthritis)
mytableFish2 <- xtabs(~Improved+Sex, data=Arthritis)
fisher.test(mytableFish)
fisher.test(mytableFish2)
library(vcd)
mytableMantel <- xtabs(~Treatment+Improved+Sex, data=Arthritis)
mantelhaen.test(mytableMantel)
library(vcd)
mytableAssoc <- xtabs(~Treatment+Improved, data=Arthritis)
chisq.test(mytableAssoc)
assocstats(mytableAssoc)
table2flat <- function(mytable){
df <- as.data.frame(mytable)
rows <- dim(df)[1]
cols <- dim(df)[2]
x <- NULL
for(i in 1:rows){
for(j in 1:df$Freq[i]){
row <- df[i, c(1:cols-1)]
x <- rbind(x, row)
}
}
row.names(x) <- c(1:dim(x)[1])
return(x)
}
mytable
x <- table2flat(mytable)
plot(mtcars)
library(multcomp)
attach(cholesterol)
table(trt)
aggregate(response, by = list(trt), FUN = mean)
aggregate(response, by=list(trt), FUN = sd)
fit <- aov(response~trt)
summary(fit)
library(gplots)
plotmeans(response~trt)
detach(cholesterol)
TukeyHSD(fit)
opar <- par()
par(las=1)
par(mar=c(5,8,4,2))
plot(TukeyHSD(fit))
par(opar)
library(multcomp)
opar <- par()
par(mar=c(5,4,6,2))
tuk <- glht(fit, linfct=mcp(trt="Tukey"))
plot(cld(tuk, level=.5), col="lightgrey")
par(opar)
attach(mtcars)
plot(wt,mpg,main = "MPG vs WT",xlab = "wt",ylab = "MPG")
abline(lm(mpg~wt), col="red", lty=1, lwd=2) # 最佳拟合线性直线
lines(lowess(wt,mpg), col="blue", lty=2,lwd=2) # 平滑拟合曲线
library(car)
scatterplot(mpg~wt | cyl, data=mtcars, lwd=2, legend.plot=T, boxplots = "xy") # | cyl,以cyl为条件分组绘图
detach(mtcars)
pairs(~mpg+wt+disp+drat, data=mtcars,main="Plot Matrix", upper.panel=NULL)
library(car)
scatterplotMatrix(~mpg+wt+disp+drat, data=mtcars, main="Plot Matrix")
scatterplotMatrix(~mpg+wt+disp+drat | cyl, data=mtcars, diagonal="histogram", main="Plot Matrix")
cor(mtcars[c("mpg", "wt", "disp", "drat")])
library(gclus)
mydata <- mtcars[c(1,3,5,6)]
mydata.corr <- abs(cor(mydata))
mydata.color <- dmat.color(mydata.corr) # 给定对称矩阵,返回颜色矩阵
myorder <- order.single(mydata.corr)
cpairs(mydata, myorder, panel.colors=mydata.color, gap=.5, main="By Corr")
set.seed(1234)
n <- 10000
c1 <- matrix(rnorm(n, mean=0,sd = .5), ncol=2)
c2 <- matrix(rnorm(n, mean=3, sd=2),ncol=2)
mydata <- rbind(c1,c2)
mydata <- as.data.frame(mydata)
names(mydata) <- c("x", "y")
with(mydata, plot(x,y, main="10000 Plot")) # 严重重叠
# 可使用封箱,颜色,透明的来处理
with(mydata,smoothScatter(x,y,main="10000")) # 利用光平滑度
# 使用hexbin()函数
library(hexbin)
with(mydata, {
xbin <- hexbin(x,y,xbins=100) # xbins=100每个格子含的点数
plot(xbin,main="xbin")
})
# 使用IDmisc包的iplot()函数
library(IDPmisc)
with(mydata, iplot(x,y,main="IDmisc")) # 以颜色显示点密度
library(scatterplot3d)
attach(mtcars)
scatterplot3d(wt, disp, mpg, type="h", highlight.3d=T, main="3D Plot") # 显示纵线
# 添加回归面
s3d <- scatterplot3d(wt, disp, mpg, type="h", highlight.3d=T, main="3D Plot")
fit <- lm(mpg~wt+disp)
s3d$plane3d(fit)
detach(mtcars)
library(rgl)
attach(mtcars)
plot3d(wt,disp,mpg,col="red", size=5)
detach(mtcars)
library(Rcmdr)
attach(mtcars)
scatter3d(wt,disp,mpg)
detach(mtcars)
attach(mtcars)
symbols(wt, mpg, circles = sqrt(disp/pi), fg="white", bg="lightblue",inches = .3)
text(wt, mpg, rownames(mtcars), cex=.6)
detach(mtcars)
opar <- par(no.readonly = T)
par(mfrow=c(1,2))
t1 <- subset(Orange, Tree==1)
plot(t1$age, t1$circumference,main="Orange")
plot(t1$age, t1$circumference,main="Orange2", type="b")
par(opar)
plot(x,y,type="")
age <- c(32,45,25,39,99)
country <- c("US", "US", "UK", "UK", "UK")
date <- c("10/24/08", "10/28/08", "10/01/08", "10/12/08", "05/01/09")
gender <- c("M", "F", "F", "M", "F")
manager <- c(1,2,3,4,5)
q1 <- c(5,3,3,3,2)
q2 <- c(4,5,5,3,2)
q3 <- c(5,2,5,4,1)
q4 <- c(5,5,5,NA,2)
q5 <- c(5,5,2,NA,1)
leaderShip <- data.frame(manager, date, country, gender, age, q1, q2, q3, q4, q5)
newName0 <- leaderShip
names(newName0)
library(reshape)
newName1 <- rename(newName0, c(manager="managerId", date="testDate"))
names(newName1)
newName2 <- newName0
names(newName2)[c(1,2)] <- c("managerId", "testDate")
names(newName2)
is.na(leaderShip$q4)
# library(sqldf)
nullData <- leaderShip
# attach(nulldata)
nullData$age[nullData$age>90] <- NA
# detach(nulldata)
nullData
colData1 <- data.frame(manager=c(1,2,3,4,5), newAge=c(leaderShip$age * leaderShip$q1)) #需要有共同列名进行内连接
mergeData <- merge(leaderShip, colData1)
mergeData
colData2 <- data.frame(childern=c(1,0,2,1,3))
cbindData <- cbind(leaderShip, colData2)
cbindData
rowData <- c(6, "10/15/08", "US", "M", 23, 4, 3, 5, 2, 1, 0)
rbindData <- rbind(leaderShip, rowData)
rbindData
class(leaderShip$date)
leaderShip$date <- as.Date(leaderShip$date, "%m/%d/%y")
class(leaderShip$date)
leaderShip
order(leaderShip$age)
order(-leaderShip$age)
orderData <- leaderShip[order(leaderShip$age),]
orderData
leaderShip[,c(1:5)]
leaderShip[c(1:3),]
leaderShip[which(leaderShip$age>40),]
paste0("q",1:5,seq="")
!names(leaderShip) %in% c("q4","q5")
leaderShip[(!names(leaderShip) %in% c("q4","q5"))]
leaderShip[c(-9,-10)]
subset(leaderShip, age<30 | gender == "F", select=c(1:5))
sample(1:100, 10, replace = F)
leaderShip[sample(1:nrow(leaderShip), 3, replace = F),]
library(sqldf)
sqldf("SELECT avg(mpg) AS avg_mpg, avg(disp) AS avg_disp, gear FROM mtcars WHERE cyl IN (4, 6) GROUP BY gear")
name <- c("J D", "A W", "B M", "D J", "J M", "C C", "R Y", "G K", "J E", "M R")
mathScore <- c(502, 600, 412, 358, 495, 512, 410, 625, 573, 522)
sciScore <- c(95, 99, 80, 82, 75, 85, 80, 95, 89, 86)
engScore <- c(25, 22, 18, 15, 20, 28, 15, 30, 27, 18)
scoreTable <- data.frame(name, mathScore, sciScore, engScore)
scoreTable
scoreTable$mathScore^0.5
normx <- pretty(-3:3,50)
normy <- dnorm(normx)
plot(normx, normy, type="l", xlab = "NormalDevinate", ylab = "Density", yaxs = "i")
set.seed(666)
# ?Quotes
cat("hello", "\bworld" )
#cat会有空格分隔,使用\b退格一个空格
rMatrix <- matrix(rnorm(30), nrow=6)
mean(rMatrix) # 得到矩阵全部元素的均值
apply(rMatrix, 1, mean) # 得到第一个维度的均值
apply(rMatrix, 2, mean) # 得到第二个维度的均值
apply(rMatrix, 2, mean, trim=.2) # 得到第二个维度截尾20%的均值
# scoreTable
zScore <- scale(scoreTable[,c(2:4)]) # 将成绩表的2-4列成绩中心化,标准化得到z分数作为综合指标
allScore <- apply(zScore, 1, mean) # 求得z分数的均值
newScoreTable <- cbind(scoreTable, allScore) # 组建新成绩表
divScore <- quantile(allScore, c(.8, .6, .4, .2)) # 划出分位数
newScoreTable$grade[newScoreTable$allScore >= divScore[1]] <- "A"
newScoreTable$grade[newScoreTable$allScore < divScore[1] & newScoreTable$allScore >= divScore[2]] <- "B"
newScoreTable$grade[newScoreTable$allScore < divScore[2] & newScoreTable$allScore >= divScore[3]] <- "C"
newScoreTable$grade[newScoreTable$allScore < divScore[3] & newScoreTable$allScore >= divScore[4]] <- "D"
newScoreTable$grade[newScoreTable$allScore < divScore[4]] <- "F" # 按分位数确定grade
stuName <- strsplit(newScoreTable$name, " ") # 以空格为分隔拆分name,返回一个列表
firstName <- sapply(stuName, "[", 1) # "["是一个提取对象某一部分的函数,此处用于提取stuName列表每个元素的第一个或第二个元素
lastName <- sapply(stuName, "[", 2)
newScoreTable <- cbind(firstName, lastName, newScoreTable[-1]) # 去除newScoreTable的第一个旧的name字段,并与拆开的firstName, lastName合并
# order(newScoreTable$firstName, newScoreTable$lastName)
newScoreTable <- newScoreTable[order(newScoreTable$firstName, newScoreTable$lastName),] # 排序
newScoreTable
for(i in 1:3){
print("hello"); # 注意分号
print("world")
}
i <- 5
while(i>0){
print(i);
i <- i-1
}
for(i in 1:6){
if(i%%2==0){
print(i);
print("偶数")
}
else{
print(i);
print("奇数")
}
}
for(i in 1:6){
ifelse((i%%2==0),{print(i);print("偶数")}, {print(i);print("奇数")})
}
feelings <- c("happy", "sad", "afraid")
for(i in feelings){
print(
switch(i,
happy="I am happy",
sad="Want to cry",
anger="Calm down",
cat("NO!"))
)
}
varOfData <- function(x){
m <- mean(x)
x <- (x-m)^2 # 直接对向量进行操作是指向量每个元素进行操作
sum(x)/(length(x)-1)
}
vectorA <- c(1:10)
varOfData(vectorA)
var(vectorA)
list(name1=q1, name2=q2)
myCars <- mtcars[1:5,1:4]
myCars
t(myCars)
attach(mtcars)
aggreData <- aggregate(mtcars, by = list(Group_cyl=cyl, Group_gear=gear),FUN = mean, na.rm=T)
aggreData
detach(mtcars)
# 按照cyl和gear分组,如第一行,cyl=4,gear=3的车子的平均mpg为21.5
reID <- c(1,1,2,2)
reTIME <- c(1,2,1,2)
reX1 <- c(5,3,6,2)
reX2 <- c(6,5,1,4)
reData <- data.frame(ID=reID, TIME=reTIME, X1=reX1, X2=reX2)
reData
library(reshape2)
meltData <- melt(reData, id=list("ID", "TIME")) # 不需指定变量的名称
meltData
library(reshape)
castDataA <- cast(meltData, ID+TIME~variable) # 行为ID,TIME,列为variable
castDataA
castDataB <- cast(meltData, ID+variable~TIME) # 行为ID和variable,列为TIME
castDataB
castDataC <- cast(meltData, ID~variable+TIME) # 行为ID,列为variable和TIME
castDataC
castDataD <- cast(meltData, ID~variable, mean) # 行为ID,列为variable,并求相应ID的variable均值
castDataD
normx <- pretty(-3:3,50)
normx
x <- pretty(1:50,100)
y <- dnorm(x)
plot(0:length(a), x, type = "l")
x <- pretty(1:50,100)
y <- dnorm(x)
plot(x,y, type = "l")
x <- pretty(0:50,100)
y <- dnorm(x)
plot(x , y, type = "l")
x <- pretty(0:50,100)
y <- dnorm(x,5)
plot(x , y, type = "l")
x <- pretty(-3:3,50)
y <- dnorm(normx)
plot(x, y, type="l")
x <- pretty(-3:3,500)
y <- dnorm(normx)
plot(x, y, type="l")
x <- pretty(-3:3,500)
y <- dnorm(x)
plot(x, y, type="l")
x <- pretty(0:50,1000)
y <- dnorm(x,5)
plot(x , y, type = "l")
x <- pretty(0:50,100)
class(x)
y <- dnorm(x,5)
plot(x , y, type = "l")
x <- pretty(0:50,100)
mode(x)
y <- dnorm(x,5)
plot(x , y, type = "l")
x <- pretty(0:50,100)
is.vector(x)
y <- dnorm(x,5)
plot(x , y, type = "l")
x <- pretty(0:50,100)
is.list(x)
y <- dnorm(x,5)
plot(x , y, type = "l")
x <- pretty(0:50,100)
x
y <- dnorm(x,5)
plot(x , y, type = "l")
x <- pretty(0:50,1000)
x
y <- dnorm(x,5)
plot(x , y, type = "l")
x <- pretty(0:50,100)
x
y <- dnorm(x, 5)
plot(x , y, type = "l")
x <- seq(0, 50, length.out = 100)
x
y <- dnorm(x, 5)
plot(x , y, type = "l")
x <- pretty(-3:3,500)
y <- dnorm(x)
z <- pnorm(x)
plot(x, y, type="l")
plot(x, z, type="l")
x <- pretty(0:50,100)
x
y <- dnorm(x, 5)
plot(x , y, type = "l")
x <- pretty(0:50,100)
x
y <- dchisq(x, 5)
plot(x , y, type = "l")
x <- pretty(0:50,100)
x
y <- dchisq(x, 5)
z <- pchisq(x,5)
plot(x , y, type = "l")
plot(x , z, type = "l")
x <- pretty(0:50,100)
y <- dchisq(x, 5) # 概率密度分布
z <- pchisq(x,5) # 累积概率分布
plot(x , y, type = "l")
plot(x , z, type = "l")
x <- seq(0, 50, length.out = 100)
x
y <- dchisq(x, 5)
plot(x , y, type = "l")
