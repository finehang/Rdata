---
title: "R Notebook"
output: html_notebook
---

## 数据结构
### 类型
character 字符型
numeric 数值型,实数或小数
integer 整型
complex 复数
bool 布尔型

### 结构
向量,vector
因子,factor
矩阵,matrix
数据框,dataframe
数组,array
列表,list

### 向量
```{r}
a <- c(10:20)
(seq(from=1, to=10,  length.out=10, along.with=a)) # by=1
(seq(from=1, to=10,  length.out=20)) # by=1
```
取子集
```{r}
a[1:5] # 取1-5
a[-5:-1] # 不取1-5
(which(a>15)) # 返回索引
a[which(a>15)]
```

### 因子
有level及其标签
factor()
gl()
```{r}
blood <- c("a", "a", "b", "ab", "ab", "o", "o")
(bloodFactor <- factor(blood))
(bloodFactor <- factor(blood, levels = c("a", "b", "ab", "o"), labels = c(1,2,3,4))) # 指定levels,以字符向量, labels替换显示原有字符
(gl(5,2,labels = c("A", "B", "C", "D", "E"))) # 5五个水平,每个重复2次
```

### 矩阵
```{r}
ma <- matrix(rnorm(16,0,1), nrow = 4, byrow = T)
rownames(ma) <- c(1,2,3,4)
colnames(ma) <- c(5,6,7,8)
mb <- matrix(rnorm(16,0,2), nrow = 4)
rownames(mb) <- c(1,2,3,4)
colnames(mb) <- c(5,6,7,8)
(ma + mb) # 对应相加
(ma * mb) # 对应相乘
(ma %*% mb) # 矩阵乘法
solve(ma) %*% ma # solve求逆矩阵
solve(ma, c(1,2,3,4)) # 解线性方程组

m1 <- cbind(c(1:10), c(11:20)) # 列拼
m1
m2 <- rbind(c(1:10), c(11:20))# 行拼
m2
```

### 对角矩阵
```{r}
diag(4)
diag(c(1,2,3,4,5))
diag(matrix(1:16,4)) # 提取对角线元素
```

### 数据框

data.frame()创建
$与[[]]访问
attach()与detach()
with()与within() with不改变原值,within改变
subset()取子集

```{r}
data <- data.frame(fx = rnorm(10), fy = runif(10), f = c(1:10))
data[["fy"]] # 取出的是数据框元素自己的结构
class(data["fy"]) # 取出的还是数据框
data$fy # 直接使用$比较好
data$fy[1] # fy变量的第一个观测


# attach()将对象添加进搜索路径, 应与detach()联合使用
attach(data)
search() # 查看现有搜索路径
detach(data)
search()

with(data, {fx=c(51:60)}) # 对data只读
data$fx
within(data, {fx=c(51:60)})$fx # 可对data读写

data$add <- data$fx + data$fy # 直接添加add变量


subset(data, fx>0 & fy <0.5, select = c(fy, f)) # 按条件过滤

# edit()与fix()
```
### 列表与数组

```{r}
a <- list(X=c(1:10), Y=matrix(1:16,4), Z=data.frame(A=c(1:5), B=c(6:10)))
names(a)
a$Z


d <- array(1:60, c(3,4,5)) # 三行四列五个
d
```

### 类型转换
安全级别: 字符>数字>布尔 由低向高转不会出错, 数字转字符肯定不会出错,但字符转数字就可能出错

```{r}
x <- c(1:5, "hello", TRUE)
x # 全被强制转化为较安全的字符型
y <- matrix(1:6,3)
y
mode(y) # 查看数据类型
class(y) # 查看数据结构
y1 <- as.data.frame(y) #转为数据框
y1
```

## 流程控制
### 分支结构
 if(...){
 ...
 }else{
 ...
 }

 if...else...结构

 ifelse(b, u, v)函数, 支持向量化计算

```{r}
brand <- paste(c("Brand"), 1:9, sep = "")
pName <- paste("DELL", 1:9, sep = " ")
mem <- rep(c("1G", "2G", "4G"), 3)
feq <- rep(c("2.2G", "2.8G", "3.2G"), each=3)
price <- rep(c("1000", "2000", "5000"), 3)
PC <- data.frame(brand, pName, mem, feq, price)

# 高于3000打上Expensive标签,低于为Cheap标签
for(i in 1:nrow(PC)){
  if (PC$price[i]>3000){ # 字符型数字可以和数值比较,"10">5为TRUE
    PC$tag[i] = "Expensive"
  }else{
    PC$tag[i] = "Cheap"
  }
}

PC$tag2 <- ifelse(PC$price>3000,"Expensive", "Cheap") # 第一参数为测试条件,T输出第二参数,F输出第三参数
PC
```

### 循环结构
for语句, 次数固定
  for(i in x){
    ....
  }

while语句, 次数不固定,只看条件,判断为T就执行
  while(T/F){
    ....
  }

repeat语句, 进来就一直循环,直到遇到break,必须有
  repeat{
    ....
    break
  }

break与next, break退出整个循环, next 退出本轮循环,执行下一次

```{r}
for(i in 1:5){
  print(i^2)
}

i <- 1
while(i<=5){ # 注意临界值, 和判定条件
  print(i^2)
  i <- i+1 # 注意累加
}

i <- 1
repeat{
  print(i^2)
  i <- i+1 # 注意累加
  if (i>5) break # 注意判定条件
}
```

### 函数
myfun <- function(par1, par2,...){
  ....
}

R 中函数是一类对象,如同向量列表等一样可以随时创建, 而在C等中,必须提前编译后才能使用
一类对象可以作为函数参数,也可作为返回对象

查看函数源码
不带()的函数名
page()函数, 在编辑器中查看
```{r}
mean
page(mean)
```
函数必须要返回值,不写return(), 会将最后一行作为返回值
```{r}
add <- function(x=c(1:2)){ # =定义缺省值
  return (sum(x)) # 返回对象要加上括号
}
add(1:100)
add()
```
```{r}
x <- c(1,2,3,4,NA,5,6,NA)
x
!is.na(x) # x中不为NA的为T
x <- x[!is.na(x)] # 取出不为NA的
x
```


```{r}
mystat <- function(x,na.omit=F){
  if(na.omit){
    x <- x[!is.na(x)] # 取出不为NA的
  }
  m <- mean(x)
  n <- length(x)
  s <- sd(x)
  skew <- (sum((x-m)^3)/n)/((sum((x-m)^2)/n)^(3/2)) # 偏度,越大越偏,正负为左偏或右偏
  kurt <- (sum((x-m)^4)/n)/((sum((x-m)^2)/n)^2)-3 # 峰度, 减3是与标准正态0比较,大于0尖峰分布,小于0扁平分布
  return (list(mean=m, sd=s, skew=skew, kurtosis=kurt))
}

mystat(rnorm(100))
```
使用source()载入函数文件
```{r}
source("C:/Users/fanhang/Desktop/Rdata/sk_ku.r") # 载入r文件
sk_ku(rnorm(100))
```
```{r}
sk_ku # 查看函数源码
# page(sk_ku)
```

### apply家族
apply(), sapply(), lapply(), mapply(), tapply()

apply(), 对指定的维度进行运算
apply(x, margin, FUN)
x为数据框, margin为指定的维度,1为行维度,2为列维度, FUN为指定的对行或列操作的函数
```{r}
dataTest <- data.frame(pv=rnorm(10), uv=rnorm(10), ip=runif(10))
rownames(dataTest) <- paste("NO.",1:10,sep = "")
# apply(dataTest, 1, FUN=mean) # 行维度
apply(dataTest, 2, FUN=mean) # 列维度
apply(dataTest, c(1,2), FUN=mean) #　对于FUN的参数，接在FUN后面
# 查看分位数
quantile(dataTest$pv, probs = c(.1,.6,.9))
apply(dataTest, 2, FUN=quantile, probs = c(.1,.6,.9)) # probs指定的参数是给FUN用的
```

### 切比雪夫定理
对于任意分布距离其均值k个标准差部分的概率为1-1/k^2
如k=2,则据其均值2个标准差的数据概率为3/4
$$
1-\frac{1}{k^2}
$$
### 相关关系
协方差
Cov(X, Y) 
= E[ (X-E[X]) * (Y-E[Y]) ]
= E[XY] - E[X]E[Y]

相关系数
p(X, Y)
= Cov(X, Y) / s(X)*s(Y)

### 分布函数
r 生成符合次分布的随机数
d 依据此分布的概率密度函数进行操作
p 依据此分布的累计密度函数进行操作
q 依据此分布的概率密度函数进行分位点操作
```{r}
rnorm(10) # 默认生成均值0,方差1的标准正态分布,10个随机数
dnorm(0) # 默认为标准正态分布,得到概率密度=0的概率
pnorm(1.65) # 默认为标准正态分布,得到<0的累计概率, 即1.65分位点的概率是95%
qnorm(0.95) # 与q相反,根据累计概率,得到x的值,分位点, 即95%分位点是1.65
```

### pretty()函数
pretty(from, to, length)
pretty(0,100,1000) # 从0到100,生成1000个等步长的向量

```{r}
x <- pretty(0:50,100)
y <- dchisq(x, 5) # 概率密度分布
z <- pchisq(x,5) # 累积概率分布
plot(x , y, type = "l")
plot(x , z, type = "l")
```
```{r}
x <- pretty(-3:3,500)
y <- dnorm(x)
z <- pnorm(x)
plot(x, y, type="l")
plot(x, z, type="l")
```

```{r}
x <- seq(0, 50, length.out = 100)
y <- dchisq(x, 5)
plot(x , y, type = "l")
```








